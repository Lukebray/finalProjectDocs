\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[square,sort,comma,numbers]{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage{url}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xparse}
\usepackage{xcolor}
\usepackage{hyperref}
\graphicspath{ {./images/} }
\author{Luke Bray - B00100787}
\title{Bird Nest Box Monitoring Using Raspberry Pi and Python}
\begin{document}
\maketitle
\pagebreak
\section{Abstract}
\pagebreak
\section{Acknowledgements}
\pagebreak
\tableofcontents
\pagebreak
\listoffigures
\pagebreak
\listoftables
\pagebreak
\section{Introduction}
\subsection{Background}
Man-made nest boxes are vital for native cavity-nesting birds. One of the main reasons for this is the increased competition for natural cavity spaces. Non-native invasive species such as Starlings and House Sparrows as well as increased urban sprawl have reduced the number of available natural cavities. The Irish landscape is one that is heavily agricultural and changes in agricultural policies and practices have provoked losses in biological diversity\citep{PIERRET201814}. Therefore as the Irish landscape and policies governing it change it becomes ever more important to monitor the populations of all birds to see how they are faring\citep{website:birdwatchireland}. 

Monitoring a nest box is important for many reasons. First of all it can be interesting to see what kind of species is occupying the box. However this can be achieved by simply observing the coming and going of the box inhabitants. One of the biggest threats to nest boxes can be invasive species. This can include larger bird species and small mammals as well as insects and spiders. In this case it is helpful to have a view into the box. This can be achieved by physically inspecting the nest box however this can be intrusive and disturb the wildlife inside. Thus arises a need for a remote monitoring system using a non-intrusive camera. 

Maintaining a healthy habitat is important for the wildlife inside the nest box. Different species of bird are responsive to changes in environment at varying levels and some environmental factors can be critical to the survival of some species\citep{wormworth06}. It is for this reason that some simple monitoring equipment would be useful to include in any kind of nest box monitoring system.

All of the data that will be gathered is not very useful if it cannot be stored and displayed in a meaningful way. One of the most convenient ways to view data is through a graphical means and the particular data being collected in this project may be of interest to the public and anybody who has an interest in wildlife. Therefore it will be necessary to find a suitable way to store the data and display it in a way that is accessible and engaging. 

\subsection{Aims and Objectives}
From the background information provided above it becomes clear that there are definitely two main aims of this project. There will also be a third aim that is secondary to the function of the project however is equally important. 

The first aim of this project is to have an effective and useful monitoring system. This first aim can be broken down into multiple objectives. 
\begin{itemize}
\item To use appropriate hardware to capture the most important and fundamental data. In this context hardware refers to the actual computing device as well as the sensors that will be used to collect the data. Hardware that is used to power the device is also included in this objective as this will be important to ensure the completion of the objective.

\item To have efficient and appropriate software running on the hardware. The software is important as it is what controls how the data is processed, stored and displayed. It will have to be robust enough that it can handle large amounts of data and it should be designed in a way that allows the aim to be achieved. 

\item To design a system that is unobtrusive to the wildlife that will potentially inhabit or are currently inhabiting the nest box. If the device is too obtrusive then it is unlikely that birds will actually use it as a habitat and therefore no data can be collected. Similarly if the hardware and software are not well designed then regular maintenance will have to be performed which could lead to intruding on any wildlife that may be inhabiting the nest box and rendering the habitat useless. 
\end{itemize}

The second aim of this project is to display the collected data in a suitable way. This second aim can be broken down into multiple objectives.
\begin{itemize}
\item To display the sensor data in a graph or table that is easy to read and interpret. Historical data should also be available for analysis. 

\item To display the video footage captured by the camera. It is important that the footage is displayed live and if possible alongside the sensor data. 

\item To make the data easily available to anybody who would like to view it. This will mean hosting the data online. 

\item To capture the data without significant loss. The software will need to account for periods of time in case an internet connection cannot be obtained and it should be an objective to capture all data without significant loss. 
\end{itemize}

The third aim of this project is to enhance my learning and understanding of developing software and managing a project. This third aim can be broken down into multiple objectives. 
\begin{itemize}
\item To abide by a software development process and have thorough design documentation before any implementation is done. 

\item To have a proper software testing process in place that will minimise bugs and errors at implementation

\item To design a system that allows for future expansion in case I find that the project could be expanded. 
\end{itemize}

\section{Literature Review}
\subsection{Introduction}
Birds have been used as tools all over the world for centuries for things such as hunting, entertainment and delivering messages. In the modern world birdwatching is an already a popular activity and it's recent increase in popularity has helped to integrate research into birds, bird conservation and socio-economics development\cite{Zhijun2013}. In China alone as of 2010 there were in excess of 20,000 birdwatchers\cite{Zhijun2013}. The hobby is essentially the monitoring of different bird species and recording information such as the time of year, the species of the bird and how many birds there are. Many countries have organisations where birdwatchers can submit this data and this leads to an overall picture of the welfare of a countries native species.

A parallel to this rise in birdwatchers over recent years has been the emergence of the large number physical objects which are connected to the internet, commonly known as the \textit{Internet of Things}. These devices can play a large role in our daily lives and in 2010 the number of devices connected to the internet surpassed the population of humans on Earth\cite{AlFuqaha2015} and by 2020 it is estimated that the number of IoT smart objects deployed globally will reach 50 billion entities\cite{Arumuga2017}. 

When we see the clear trend upwards in both birdwatching and smart devices connected to the IoT it becomes a natural step to combine the two and create a smart, connected device that can bring the hobby of birdwatching and all of the benefits it provides into the digital world. Birdwatching is essentially a hobby where monitoring takes place, albeit manually. It therefore seems natural with the help of small, powerful computers and all of the sensors available for them to build a monitoring device. 

In this literature review I will explore some other monitoring projects which used technology similar to that I intend to use. Creating a bird monitoring device will present some challenges such as connectivity and power supply and I will attempt to gain a better understanding of how I might cope with these challenges in my monitoring device.
\subsection{Raspberry Pi for Video Capture}
The main function of the device will be to capture a live video feed in the nest box to see what species of bird are nesting inside and some of their behaviours. One of the considerations to be taken when capturing video is how it will be transferred. Traditional monitoring camera systems such as Closed Circuit Television (CCTV) have poor video quality and rate of transfer. It is important for the device to be used for this paper to have high definition video with low latency times. One article\cite{Jennehag2016} set out to verify that high quality video could be transferred with low delay times using small, low-powered computers such as the Raspberry Pi. 

The aims of the study were to create a system that meets the following requirements:
\begin{itemize}
\item A low delay from source to sink of \textless200ms to provide an as close to live as possible viewing experience
\item High definition video content of at least 1280x720 at 25 frames per second
\item Runs on cheap, resource-constrained device such as Raspberry Pi
\end{itemize}

To achieve a stable transmission of video that does not saturate a network, video compression is usually required. One of the most popular video compression formats that is used is the H.264 and that is what is used in the article discussed here. Fortunately the Raspberry Pi camera modules (both IR and non-IR) were designed with high quality video streaming in mind and as such capture video as raw H.264 video stream\cite{piDoc}. The H.264 codec was created to provide good video quality at lower bit rates which makes it an ideal format for internet video streaming\cite{Wiegand2003}. The article discussed found that from source to sink, the average delay was 181ms at the specified resolution which met the requirements of their study.

One problem with the above study is that all of their tests were done using wired connection since the Raspberry Pi 2B that they used didn't have the ability to transmit via wireless connection. Given the remote nature of the monitoring system for this project the connection will most likely have to be wireless and I would expect that delay time will be greater than 181ms. However the study did find that 90\% of the total delay is due to the encoding and decoding of the video so I believe the increase in delay using a wireless transmission will be minimal. I am also happy that very low delay times are not a key requirement of this project.
\subsection{Raspberry Pi as Monitoring Device}
While live video feed is intended to be the main function of this device, the secondary function is to monitor the environment the device is placed in and measurements will be recorded by the device to achieve this. 

Many other papers have attempted to do this. One such paper, which was intended to create an IoT urban based climate monitoring system, found that due to its low cost and high reliability the Raspberry Pi was a good choice for a small, low powered monitoring system\cite{Shete2016}. The study used a Raspberry Pi 2 Model B along with 5 sensors to provide a broad overview of the surrounding environment. The system used Adafruit IO which provides different libraries that are used for implementing an IoT device. The libraries are available in many different languages however the one that was used here was Python. Adafruit IO can also generate a dashboard automatically containing graphs of the outputs from the various sensors which was useful to the study to display data in a meaningful, easy-to-understand way. 

One of the issues that the article discussed above did not address is how the device is powered. This is an important aspect of a monitoring device as they need to be constantly running to collect meaningful data.

Another study\cite{Sriyanka2017} used an Arduino board to house the sensing units which then transferred the data via Zigbee to the Raspberry Pi 3 which uploaded and processed the data onto the internet. The advantage of this is that the Arduino can be used as a separate sensing unit and the Pi can be used as the computing unit. This will increase performance across the two devices although it does add complications because the data has to be transferred to the Pi and then also to the internet. This wouldn't be a problem for a device that doesn't make use of Pi Camera module because the Pi can be safely located indoors however for this project the Raspberry Pi must be located close to the nest box so that the Pi Camera can be attached inside. 

Another problem with the above study is that it does not mention how the Arduino sensor module or Raspberry Pi are powered. They have stated that the system could potentially run for months without human intervention but have not discussed how the devices could be powered for this amount of time. This is something that I will try to discover in the next section.
\subsection{Powering the Raspberry Pi}
Raspberry Pi is powered by a +5.1V micro USB port and it is recommended to purchase a 2.5A power supply for stability reasons. According to the documentation a typical Raspberry Pi 3 Model B can use between 700-1000mA\cite{piDoc}. 

One paper set out to achieve an accurate estimation of the Raspberry Pi's power consumption and see if they could reduce power consumption by optimizing the software running on the platform\cite{Kaup2014}. In the study they set the Pi up to run only essential operations and specifically wrote lightweight utilization software to reduce power consumption while still achieving their goal. The monitor was not even permitted to write to the SD card, instead writing the results to RAM and copying the data after the monitoring had finished. The above was done with the intention of being able to monitor system utilisation without the process of monitoring affecting results. 

The study then used software called \textit{cpulimit} to generate load on the system. This software creates an infinite loop which adds numbers until the CPU load is at the desired limit. The study ended up with 900,000 power measurements which were combined and plotted logarithmically in a heat map fashion on the graph below\cite{Kaup2014}:

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/powerconsumption.png}
  \caption{Power consumption vs. CPU utilisation}
  \label{fig:pwervscpu}
\end{figure}

The graph shows that CPU usage and power consumption have a linear relationship and as CPU usage reaches 100\% power consumption is at approximately 1.75W or 1750mA. This far exceeds what is stated in the documentation from Raspberry Pi although it can be argued that a Raspberry Pi will very rarely be close to 100\% CPU usage for any extended period of time. The study also attempted to model power consumption during network transmissions and found that using Ethernet consumed far less power. At 50MBit/s Ethernet had upload/download power consumption of ~0.3W and ~0.32W respectively. While WiFi used over 1.5W on both upload and download. 

The study above is a good example of how to measure the power consumption of a small device and could be easily adapted to measure devices other than the Raspberry Pi. It does highlight the need to think carefully about the types of transfer methods used as these can clearly have a significant impact on power consumption.
\subsubsection{Solar Power}
It seems that the most efficient way to power a monitoring system would be to use a renewable energy source. The most accessible and affordable is solar power. A solar power system has three main components: 
\begin{enumerate}
\item\textit{The Solar Panel} - This is what most people think of when they think of solar power. It is a panel that uses the photovoltaic effect to convert sunlight and to electricity and is the core of any solar power system.
\item\textit{The Solar Controller} - This is an important part of any solar power system. It's role is to regulate the amount of charge coming from the panel to the battery and prevent overcharging\citep{website:energymatters}. Devices can also be charged directly from the solar controller with some versions even including 2.5A USB ports which are ideal for charging devices such as Raspberry Pi.
\item\textit{The Battery} - This part of the solar power system is optional. If you have a device which is being charged directly then there will be no need for this part of the system however it could be important in climates where there is not a lot of sunlight or if you have a device that needs to be powered overnight.
\end{enumerate}

With the three components above a typical solar power system circuit diagram might look like the one below\citep{website:edgefx}: 

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/solarcircuit.jpg}
  \caption{A basic solar circuit}
  \label{fig:solarcircuit}
\end{figure}

\subsection{Raspberry Pi Connectivity}
There are multiple options available for connectivity to the Raspberry Pi and 3 of the main methods will be explored below.
\subsubsection{WiFi} 
The latest model of the Raspberry Pi comes with a built in 2.4GHz 802.11n wireless adaptor, allowing it to transmit data without any need to external adaptors or wires. There are many WiFi standards available however the most prominent is 802.11n and it is found in most wireless devices such as smart-phones, tablets and laptops. There is a competitor called 802.11ac which was developed to handle larger files and faster speeds. Several studies, including one by Ruckuswireless\cite{Ruckus2014}, have found that 802.11ac is a superior connectivity standard to 802.11n however the low cost of 802.11n has meant it has become the favoured standard and this is why it appears in the Raspberry Pi. 

802.11n can transfer data with throughput up to 300Mbps and over distances of 70 metres in open structure environment and 250 metres in open air environment\cite{Kaewkiriya2017}. This makes it ideal for transfer of relatively small amounts of data from a monitoring station however power consumption and reliability of WiFi in general still remain a cause for concern. WiFi also has quite weak security and the size of a WiFi network must remain relatively small with a maximum of around 16 devices on any normal network.  
\subsubsection{Wired Transfer}
Raspberry Pi 3 Model B comes with 1 Gigabit Ethernet over USB2.0 port. The use of USB2.0 means that the throughput is limited to 300MBps - the same as WiFi. We have already seen in\cite{Kaup2014} that Ethernet connections use significantly less power than WiFi however because the transfer is via USB2.0 we do not see the speed advantages that Ethernet connections generally offer. We will still get a faster connection because there will be no loss as there is with WiFi and using a wired connection means we get more stable speeds. Wired Ethernet connections are also more reliable that WiFi connections due to the removal of any chance of network interference from other transmissions.
\subsubsection{Zigbee Wireless Protocol}
Zigbee is wireless specification based on IEEE 802.15.4 that was first seen in 2007 and is widely used in wireless monitoring devices due to it's low-cost and low-power requirements. This protocol describes only the MAC and physical layers\cite{Elarabi2015}. Zigbee uses small, low-powered and low-cost radios to transmit signal. The data transfer rate of Zigbee is 250Kbits/sec. It can operate on 2 regional frequency bands (868MHz in Europe, 915MHz in America) and 1 global 2.4GHz frequency band\cite{ZigbeeAlliance}. 

A strength of Zigbee is that it can transmit signal at distances of up to 100m between sender and receiver. One criticism has been that their needs to be line of site between sender and receiver however there have been papers that suggest signal strength may not be affected by obstacles. Idoudi, 2013 used the Received Signal Strength Indicator (RSSI) to show that there was little other than distance between two nodes that negatively affected RSSI values and that distance had a more negative effect on RSSI than any obstacles in the way\cite{Idoudi2013}. However the study did not state the distance between two nodes when the obstacles were placed between them. RSSI indicates the strength of the signal at the receiving node. 

Interference with Zigbee from WiFi can also occur and this is one of the main drawbacks of Zigbee, along with the rate of transfer. Zigbee uses 16 channels within the 2.4GHz band and these directly overlap with the 3 channels used by WiFi. This is shown in the figures below \cite{zigbeechannels}:

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/wifi_channels.png}
  \caption{2.4GHz WiFi Channels}
  \label{fig:wifichannels}
\end{figure}

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/zigbee_channels.png}
  \caption{2.4GHz Zigbee Channels}
  \label{fig:zigbeechannels}
\end{figure}

Usually the Zigbee network is the network that will lose packets. The sideband lobes of the WiFi signal can easily drown out the less powerful Zigbee signals. This is one of the biggest problems with Zigbee and careful planning is required when it will be used in close proximity with any WiFi-enabled devices.

\subsection{Python Web Frameworks}
A key aspect of this project is to display the collected data in a way that is appealing and accessible. This will most likely mean displaying the data on a web page. However due to the rapid evolution of the World Wide Web it has become difficult to utilise all of the technologies required for good web development\citep{pop_altar_2014}. Using a web framework can be a good way to tie the various technologies together to allow for quicker development and also to facilitate future expansion more easily. This section will look at three Python web frameworks and discuss some of their features. 
\subsubsection{Django\citep{website:django}}
Django is a free, open-source Python web framework. It is a Model View Controller (MVC) style framework and is focused on never having to repeat yourself when programming. Django is a framework that allows for quick development and minimal repetition of code. It also ensures that your app is secure against a multitude of vulnerabilities. This richness of features is also one of the main criticisms against Django. While the vast array of features may be ideal for a large scale project, they are not needed for a smaller scale project. Django is also considered to be quite monolithic and not hugely flexible. You get features such as admin panels and database interfaces out of the box which means it is not nearly as customisable as some other frameworks. 
\subsubsection{Flask\citep{website:flask}}
Flask is seen by many to be the main rival to Django. Like Django, it is a MVC style framework however it is not nearly as feature-rich and provides only the more essential features. This more minimalist design means that Flask may be better suited to smaller project however there are some large projects such as Netflix and Pinterest which are built on Flask. This may be an indicator that there is also good scalability with Flask. 
\subsubsection{Dash\citep{website:dash}}
Dash is a micro-framework that is built on top of Flask and Plotly.js. The framework includes various UI elements and allows you to tie them together with Python code while also retaining all of the benefits of using a MVC framework like Flask. Dash is specially built to be used for building analytical web applications and this makes it ideal for a project where data is to be presented and analysed. 

\section{System Requirements and Design}
\subsection{Introduction}
This chapter will outline the key requirements of this project and will then identify how the key software components interact with each other to meet these requirements. Requirements will mainly be derived from use cases and these will be important in identifying any previously unforeseen issues that may arise. UML diagrams will demonstrate the context and modes of use of the system as well as the system architecture, primary system objects, design models and specific interfacing methods. 

\subsection{Use Cases}
\subsubsection{Stream a Live Video Feed}
\begin{table}[h!]
\centering
\begin{tabular}{p{2cm}p{9cm}}
\toprule
\textbf{Use Case}    & Stream live video feed                                                                          \\ \midrule
\textbf{Actors}      & PiCamera, Raspberry Pi                                                                          \\
\textbf{Description} & The PiCamera sends live video over the internet to YouTube while the device is running         \\
\textbf{Stimulus}    & Started via command in command line                                                             \\
\textbf{Response}    & Video data is captured according to settings in command and is streamed to Youtube              \\
\textbf{Comments}    & The streaming of video data will rely on a constant internet connection as well as power supply \\ \bottomrule
\end{tabular}
\caption{Use Case 1 - Stream a live video feed}
\label{tab:useCase1}
\end{table}

\subsubsection{Record Environmental Data}
\begin{table}[h!]
\centering
\begin{tabular}{p{2cm}p{9cm}}
\toprule
\textbf{Use Case}    & Record environmental data                                                                          \\ \midrule
\textbf{Actors}      & Data sensors, Raspberry Pi, web server                                                                          \\
\textbf{Description} & The various sensors will record data about the environment including if it is raining or not, temperature and humidity. The data will be sent to a web server         \\
\textbf{Stimulus}    & Triggered by software application\\
\textbf{Response}    & Data is captured and sent to the web server              \\
\textbf{Comments}    & The streaming of data will rely on a constant internet connection as well as power supply \\ \bottomrule
\end{tabular}
\caption{Use Case 2 - Record environmental data}
\label{tab:useCase1}
\end{table}

\subsubsection{Display Environmental Data}
\begin{table}[h!]
\centering
\begin{tabular}{p{2cm}p{9cm}}
\toprule
\textbf{Use Case}    & Display environmental ata on a web page \\ \midrule
\textbf{Actors}      & Data sensors, PiCamera, Raspberry Pi, web server, web page, web user                                                                          \\
\textbf{Description} & The website will make a request to the web server to grab the data and the data will then be output to the web page in a way that is visually appealing         \\
\textbf{Stimulus}    & Triggered by user accessing the web page\\
\textbf{Response}    & Data is retrieved from the web server and displayed on the web page              \\
\textbf{Comments}    & The streaming of data will rely on a constant internet connection and the web server to remain connected \\ \bottomrule
\end{tabular}
\caption{Use Case 3 - Display environmental data}
\label{tab:useCase3}
\end{table}

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/use_case_diagram.png}
  \caption{Use Case Diagram}
  \label{fig:usecasediagram}
\end{figure}

\subsection{System Requirements}
\subsubsection{PiBB - SR001}
The system will be able to output a live HD video feed of the inside of the dark nest box. This allows a user to see if anything is living inside of the nest box.
\subsubsection{PiBB - SR002}
The system will be able to record environmental data about the nest box and send it to a web server.
\subsubsection{PiBB - SR003}
The web server must be able to display live data and the web page must update dynamically to display the latest data
\subsubsection{PiBB - SR004}
The system will be able to interpret the data received from the sensors and display live data on a dynamic web page. This allows a user to see environmental data.
\subsubsection{PiBB - SR005}
The system will be able to be deployed remotely and outside. This will mean having a renewable power source and wireless internet connection. The system must be weatherproof.
\subsubsection{PiBB - SR006}
The system will be able to manage power failures in a way that does not corrupt or damage files on the system
\subsubsection{PiBB - SR007}
The system must not be obtrusive to the wildlife occupying the nest box and must be as discreet as possible. 
\subsubsection{PiBB - SR008}
It must be possible to access the system remotely to perform necessary software maintenance once it is deployed. 
\subsubsection{PiBB - SR009}
The sensor and camera controllers must be built using Python programming language.
\subsubsection{PiBB - SR010}
The web application should be built using a Python framework.
\subsection{Power Supply}
The device will be provided with power via solar panel. Solar power has been chosen because it is a renewable energy source therefore being environmentally friendly. Having solar power also removes the need for an electricity supply and this makes the device more portable and increases the versatility. 

Power consumption of the Raspberry Pi with various configurations is shown in the below table. 

\begin{table}[]
\centering
\begin{tabular}{lllllllll}
\hline
\multicolumn{1}{c}{\textbf{Configuration}}                      & \multicolumn{1}{c}{\textbf{Volts}} & \multicolumn{1}{c}{\textbf{Amps}} & \multicolumn{1}{c}{\textbf{Watts}} & \multicolumn{1}{c}{\textbf{Watts (+15\%)}} & \multicolumn{1}{c}{\textbf{24 Hour Requirement (W)}} & \multicolumn{1}{c}{\textbf{18 Hour Requirement (W)}} & \multicolumn{1}{c}{\textbf{12 Hour Requirement (W)}} & \multicolumn{1}{c}{\textbf{6 Hour Requirement (W)}} \\ \hline
Raspberry Pi                                                    & 5.06                               & 0.4                               & 2.0                                & 2.3                                        & 56                                                   & 42                                                   & 28                                                   & 14                                                  \\
Pi + Data Sensors (Streaming Data)                              & 5.06                               & 0.4                               & 2.1                                & 2.4                                        & 58                                                   & 43                                                   & 29                                                   & 14                                                  \\
Pi + Data Sensors (Streaming Data) + PiCamera (Idle)            & 5.09                               & 1                                 & 5.1                                & 5.9                                        & 140                                                  & 105                                                  & 70                                                   & 35                                                  \\
Pi + Data Sensors (Streaming Data) + PiCamera (Streaming Video) & 5.09                               & 1.3                               & 6.6                                & 7.6                                        & 183                                                  & 137                                                  & 91                                                   & 46                                                  \\
                                                                &                                    &                                   &                                    &                                            &                                                      &                                                      &                                                      &                                                     \\ \hline
\end{tabular}
\caption{Raspberry Pi Monitoring System Power Requirements}
\label{tab:powerRequirements}
\end{table}

As can be seen from the table above, to run the system for 24 hours would require 183W of power. However running the system for 18 hours per day only requires 137W. With a 60W solar panel this could be achieved with 3 hours of sunlight per day. 

As the device will be located in Ireland it is important to have an understanding of the sunshine levels. Ireland get on average 1100-1600 hours of sunshine per year\citep{website:metsunshine}. This translates to roughly 5-6.5 hours in the Summer months and 1-1.5 hours in the Winter months. This means that in the Summer months the device may be able to run for up to 18 hours per day. Cloud cover is not as predictable of sunshine hours and so the actual amount of sunlight the panel receives may be less than anticipated. In this case the device will have to run for less time during the day or a larger solar panel will have to be installed. 

The solar system will power the device and will simultaneously charge a 12V battery. The system will consist of a solar panel, solar charge controller, 12V battery and the device itself. A diagram of the proposed solar system is shown below. 

INSERT DIAGRAM HERE

\subsection{Connectivity}
A key requirement of this device is that it is able to function as a remote monitoring device. While Ethernet may be the most reliable form of connection, it is not the most portable as the range is limited by the length of cable you have. 

Another method that was discussed was Zigbee wireless transfer. However this method of transfer is very slow at approximately 250Kbit/sec. This would be good enough for data transfer to an external server but not video streaming. The range of Zigbee is also only 300m and this requires line of site meaning location of the remote device will be limited. 

This leaves WiFi to transfer the data. The device will connect to a 4G hotspot allowing it to use WiFi to stream video and send data to a web server. The provider will be Three who allow unlimited data and the portable hotspot will be powered by a battery pack at first with the option being powered by the solar system later on if it is efficient enough when implemented. 

\subsection{PiCamera}
To satisfy the requirement of capturing video footage from inside a dark nestbox the camera must be able to see in the dark. This can be achieved using a camera without an infra-red (IR) filter however there must also be an IR-emitting source for the camera to pick up. This device will use a specially modified PiCamera which will have no IR filter. Attached to the camera will be two IR-emitting bulbs and this will bathe the inside of the nest box in IR light which the camera can then pick up. 

The actual video footage can be streamed using a package from Libav called avconv. Avconv is a very fast audio and video converter which can process raw audio and video frames, convert them to the specified format and then encode and output them to a video streaming platform\citep{avconv}

\subsection{Web Framework and Data Display Web Page}
The web framework that will be used is called Flask. Flask is a more minimal Python web framework than Django and this means that it is more configurable and easier to set up. Flask uses SQLAlchemy which is the Python toolkit for working with SQL databases and this will make it easier to work with the large amounts of data this project will eventually accumulate. Flask makes use of Jinja2 which is a HTML templating language specifically made for use with Python. The use of this templating language should make creating the web page front end a lot simpler.

The web page will be a minimal single page displaying only an embedded video of the live stream and some chart components. The chart components will be created using the charts.js library and the live video will be hosted on YouTube and embedded into the site. Below is a sample wireframe of the web page. 

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/web_page_mock_up.png}
  \caption{Web Page Wireframe}
  \label{fig:webwireframe}
\end{figure}

\subsection{Object Classes}
The object classes presented in the diagram below are based on the hardware objects and data objects in the system as well as the controlling objects such as the Raspberry Pi itself. A summary of each object is presented below:
\begin{itemize}
\item DHT11 Sensor \& Rain Sensor - The hardware objects that are responsible for the data gathered in the system
\item PiCamera - This hardware object is responsible for capturing video data of the inside of the nest box
\item Raspberry Pi - The device which controls the system and is responsible for performing actual transmission of data. It's main function is to be a vehicle for management of the hardware components
\item Environmental Data - This object summarises the data gathered from the hardware instruments
\item Web App - This object is responsible for displaying data to the user 
\end{itemize}

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/objects.png}
  \caption{Object Diagram}
  \label{fig:objects}
\end{figure}

\subsection{Development Environment Setup}
\subsubsection{Raspberry Pi}
The operating system used on the Raspberry Pi is called Raspbian OS (version 9). Raspbian is a debian-based operating system and is officially provided by the Raspberry Pi Foundation meaning it is the most compatible to run on a Raspberry Pi. I expect that using Raspbian will limit any potential issues. 

The installation process is very simple. I have downloaded NOOBS (New Out Of the Box Software) and copied the downloaded files to a newly formatted 16GB SD card. Then when booting the Raspberry Pi I selected Raspbian and the OS was installed without issue. 

Raspbian comes loaded with a Python 3 development environment which includes an installation of Python 3 and a Python IDE (Thonny). The development of data handling software will be done in this environment. 

The Raspberry Pi had to be configured to set up the VNC server. This can be done by opening a terminal and typing \begin{verbatim}
sudo raspi-config
\end{verbatim} From here the VNC server is enabled by selecting Interfacing Options \textgreater VNC and enabling the server.

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/vncserver.png}
  \caption{Enabling VNC Server}
  \label{fig:vncserver}
\end{figure}

A similar process has to be performed for the Rasperry Pi Camera. This leaves the Raspberry Pi configured and after updating it is ready to use for development.

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/picamera.png}
  \caption{Enabling PiCamera}
  \label{fig:picamera}
\end{figure}

\subsubsection{Web Development Environment}
This project will use a web development environment called Python Anywhere. This is a web environment that allows access to the project from any web browser. Python Anywhere allows for easy creation of web apps using the most popular Python web frameworks and also allows for easy SQL database creation as well as providing the ability to run multiple consoles. There are security features built into Python Anywhere and it makes it very easy to obtain things such as HTTPS certificates. The versatility of Python Anywhere is the main reason I have decided to use it and not having to set up a Python environment on multiple machines is hugely beneficial. Also all of the code and databases are in the cloud which, when combined with version control such as Git, means that the project will be safer from any potential data loss.

Setup of a new web app is as easy as selecting the Framework you'd like to use and the version of Python to use.

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/webappframework.png}
  \caption{Selecting a web framework on Python Anywhere}
  \label{fig:picamera}
\end{figure}

\begin{figure}[H]
\centering
  \includegraphics[width=\linewidth]{images/webapppython.png}
  \caption{Selecting a which version of Python to use}
  \label{fig:picamera}
\end{figure}

Actual development of code will be done on my local machine using VSCode. The whole project will be stored in a Git repository which can then be cloned into Python Anywhere using one the virtual consoles. 

\section{Software Development Approach}
\subsection{Introduction}
Even in the early days of software engineering the criticality of having a sound software development approach was recognised. It can be easy to delay or avoid completing this process while deficiencies in it can be very difficult and expensive to correct later on. Other issues arise such as the user feeling alienated due to lack of transparency or documentation and testing being hard to define\citep{1674590}.

This chapter will attempt to clearly define the software development model I intend to follow. It will also state my understood importance of each stage of the life cycle. 
\subsection{SDLC Models}
\subsubsection{The Waterfall Model}
What is the Waterfall Model and some of it's advantages and disadvantages
\subsubsection{Agile Development}
What is Agile development and what are it's advantages and disadvantages. How do they relate to my project? 

\subsection{Introduction}
This will contain info about the SDLC method I will use and a brief explanation of what this method involves
\subsubsection{Planning}
Importance of planning. Some methods that can be used to plan effectively and efficiently
\subsubsection{Designing}
Importance of good design and some ways to ensure a good design 
\subsubsection{Building}
Which specifications will be followed when building the physical housing for the product. Why is this important and how do I make sure that I stick to these specifications. What technical drawings are needed
\subsubsection{Testing}
Importance of testing and how testing will be carried out. What kind of tests need to be run to ensure a complete product
\subsubsection{Developing}
Which language will be used. Some best practices for software development and the importance of using international and industry-recognised coding practices and standards 
\subsubsection{Implementing}
How to implement a finished product. Is this done incrementally and step by step or is the final version of the product released once it is finished? How is a product updated and maintained and the importance of this from a developers point of view and a consumers



\subsection{Conclusion}
What can I conclude from the above? My thoughts on how all the above information pertains to my project and some things I will have to be especially concious of during this project 

\section{Implementation} 
\subsection{Introduction}
This chapter will cover how the software has been developed and how it is used within the project. It will aim to layout the different technologies that have been used, how they have been implemented and finally how they all work together to achieve the system requirements set out earlier in this document.

\subsection{System Overview}
The physical prototype was built and is explained later in this chapter. A bash script has been written so that on startup a linux command is automatically executed and this begins the streaming of the PiCamera to Youtube. The same bash script will also run dataSend.py. which uses classes dht11.py and rainSensor.py to record data. The data is then inserted into the MySQL database where it can be displayed on a web page. The Flask app processes the data and passes it to main.html and using the charts.js library the data is then displayed in a presentable manner. Main.html also embeds the live stream from Youtube. 

\subsection{Physical Environment Setup}
The first step of implementation was to get the hardware circuit working. The four main components are the Raspberry Pi, a DHT11 temperature and humidity sensor, the NoIR PiCamera and an FC-37 rain sensor. Initially these were implemented into a circuit using a breadboard. This allowed for a less permanent and more flexible setup for testing purposes. The circuit diagram is shown below along with some photographs of the hardware setup. 

INSERT CIRCUIT DIAGRAM AND PHOTOGRAPHS

\subsubsection{Circuit Details}
The breadboard is connected to the 3.3v GPIO pin and this supplies power all along the connected rail. There is a 5v pin available however using this requires the inclusion of various resistors in the circuit and this would introduce unnecessary complications. The 3.3v pin also supplies plenty of power for all of the components. A ground pin on the Raspberry Pi is connected to the negative rail on the breadboard. A diagram of the Raspberry Pi Model 3 GPIO pins is shown below. 
\begin{figure}[H]
  \centering
    \includegraphics[width=\linewidth]{images/gpio-pins.png}
    \caption{A diagram of the GPIO pins on a Raspberry Pi Model 3}
    \label{fig:gpiopins}
  \end{figure}

Both the FC-37 and DHT11 sensors need 3 of their pins to be connected to the GPIO pins. The FC-37 consists of two components. These are the collector board and electrical board and when enough water is collected on the collector board there is a lower output voltage which signifies rainfall. The collector board connects to the electrical board which in turn connects to the Raspberry Pi. One pin on the electrical board is connected to the power rail on the bread board while another pin is connected to the ground rail. The third pin is the data pin and this is connected to the GPIO pin on the Raspberry Pi. In this case the FC-37 was connected to GPIO pin 27. The electrical board also houses a potentiometer and this can be used to adjust the sensitivity of the collector board. This was done by putting an amount of water onto the collector board and turning the potentiometer until is detected a change in the flow of current.

INSERT PICTURE OF FC-37

The DHT11 sensor was connected in a similar way to the FC-37. One sensor pin is connected to the power supply, one to the ground rail and the final pin is connected to a GPIO pin. In this case it was GPIO pin 17. 

INSERT PICTURE OF DHT11

The NoIR PiCamera is the least complicated piece of hardware to install. There is already a dedicated slot on the Raspberry Pi which is shown below. The camera is connected into this slot and enabled as described in the previous chapter on the Raspberry Pi itself. 

INSERT PICTURE OF CAMERA SLOT

\subsection{Data Collection}
\subsubsection{dht11.py}
This class was used to collect the temperature and humidity readings from the sensor. I did not write this class. There are many different classes written in Python that will interpret the data from a DHT11 sensor and given that the way the sensor gather data is quite complex, the decision was made to not write this class myself. The DHT11 class is used under the MIT licence - a copy of which can found in the appendixes of this document. 

\subsubsection{rainSensor.py}
This class is what is used to collect rain data. The class contains a constructor function which allows the user to import the class to another Python script. When initialising the new object the user can also use the relevant GPIO pin number as an argument. 

The main function of the class, \texttt{read()}, sets up the GPIO pin. When water is present on the collector board the state of the GPIO will be equal to zero and the function will return \texttt{1} meaning it is raining. Otherwise it will return \texttt{0}. 

\subsubsection{dataSend.py}
This is the main data collection class and ties together the classes outlined above. 

The class has a main function, \texttt{weatherData()}, which collects the data using the classes above and then prints the results to the console. The function then constructs an SQL query and inserts it to the data base. The function is contained within an infinite \texttt{while()} loop and makes use of  \texttt{time.sleep()} so that the amount of time between each dataset can be easily configured. The function is defined at the very beginning of the script. 

The main function is then defined. The first thing this function does is use SSH tunnelling to establish a connection to the database. The database is hosted on PythonAnywhere.com so tunnelling had to be used. I used the \texttt{sshtunnel} Python library to do this. \texttt{MySQL.connector} is then used to establish a connection with the database. The function then checks for a successful connection and if the connection is successful \texttt{weatherData()} will run. Otherwise an error message will be printed to the console. 

An advantage of the above process and the system design is that it isolates the data collection step of the entire process. This way it is very easy to test if the data is being collected and when errors occur they can be quickly diagnosed and resolved. At this point in the process to Raspberry Pi and data collection step is complete. 

\subsection{MySQL Database}
The database is hosted on Python Anywhere and uses MySQL 5.7.21. There are 5 columns in the database and they are listed below. 
\begin{itemize}
\item id - This is just a standard incrementing id field
\item datetime - This stores the datetime value. These values will be used as the labels in the charts
\item temp - holds an int value for the recorded temperature
\item humidity - holds an int value for the recorded humidity percentage. This doesn't need to be a float as the DHT11 sensor will only record humidity in whole integers
\item rain - This is another field with int data type
\end{itemize}

\subsection{Data Processing and Presentation}
Now that the data has been recorded and passed from the Raspberry Pi to the database it can be processed and displayed on the web page. Again, Python is being used to achieve this along with other technologies like JSON, Javascript and HTML. Jinja2 template language is available for use within Flask applications however since this is only a single page application it was not needed. 

\subsubsection{Flask\_app.py}
This is the main controller and handles the passing of data to \texttt{main.html}. Navigating to \url{https://www.lukebray.ie/} will return the \texttt{main.html} template. A route has also been set up at \url{https://www.lukebray.ie/get_data} to trigger the retrieval and JSON-ification of data from the database. The raw JSON-ified data can be viewed here. Once this route is called a connection to the database is established and a cursor object from \texttt{MySQL.connector} is created. This object is used to execute an SQL query to the database and the requested data is then returned using the \texttt{fetchall()} function and assigned to a variable \texttt{r}. 

Four empty Python lists are instantiated - one for each column in the database excluding the id column. A \texttt{for} loop now runs through all of the returned rows and for each row inserts the relevant piece of data into the relevant list. 

Since the rain sensor returns a value of -1 if it isn't raining I decided to add some extra code here to assign a value of \texttt{True} or \texttt{False} depending on the integer that is in the database. This made it easier going forward to get a quick idea of the value. 

The lists are then converted to a JSON format using the JSON library for Python and stored in an array called \texttt{payload}. 

\subsubsection{main.html}
This file is where the data is displayed to the user. Bootstrap and JQuery were used to give the page a nice look and feel. These libraries also help with keeping the page so that it is responsive and will work across many devices. The charts were made using the charts.js library for Javascript. The Javascript logic is contained below the HTML content and I will explain it below. 

First the script defines a function \texttt{getFreshData()} to get the fresh data when requested. This function uses an Ajax call to get the data from \url{/get_data} and then assigns it to an empty JSON array called \texttt{data}. 

Ajax stands for Asynchronous Javascript and XML and it is in the Asynchronous nature of the call that I had the biggest issue to overcome. \texttt{getFreshData()} can easily make the Ajax call however it cannot process any of the data that is returned from the call. For example, the application retrieves all of the data in one large array. These need to be split into smaller arrays such as \texttt{\_rainData} and \texttt{\_humData}. Because the call is Asynchronous and Javascript executes sequentially it means that the next lines of Javascript are already executing before the Ajax call can return the data. Because the data is always changing it needs to be retrieved every few seconds. This fact combined with the Asynchronous nature of Ajax calls meant that I could not have a single function to get the data and assign the variables. The solution to this issue will be explained below as it is influenced by another factor of the design. 

Charts.js requires that a container called a canvas be created to hold the chart and so this is done next. I also created a function called  \texttt{createLineChart(chartName, data, canvas)} which creates a line chart. 

As previously mentioned, the data in the database is continuously changing. This means that a static chart will not serve a purpose and so it needs to be updated dynamically. To achieve this I first drew a static chart so that there would be some data displayed when the chart loads. Then the chart and all of the logic associated with it is contained within a \texttt{setInterval()} function. 

Within in the above function is where the earlier issue with the Ajax calls is resolved. The call is made using \texttt{getFreshData()}. The returned JSON array is then parsed and split into smaller arrays as follows: 
\begin{itemize}
\item \texttt{\_tempData}
\item \texttt{\_humData}
\item \texttt{\_isRaining}
\item \texttt{\_labels}
\end{itemize}

For temperature and humidity the most recent value in the array is used to display the current temperature/humidity value in the cards at the top of the page. Rain status is also displayed here. 

The chart is then drawn using the earlier defined \texttt{createLineChart()} function. The now parsed data is passed into the function along with the canvas and the name of the chart. This process is repeated every two seconds. This is advantageous in that it means the data is current however it does mean that \texttt{flask\_app.py} is making constant calls to the database. Unfortunately due to the nature of this project that is unavoidable however using Javascript with Charts.js means most of the data processing is done client-side. 

\subsubsection{Linux Automated Bash Scripts}


\section{Testing and Evaluation}
\subsection{Introduction}
Why testing is important for this product and what tests need to be done to ensure a good prototype
\subsection{Testing Methodology}
Howe to be scientific about testing and create complete and useful tests. The testing timeline will be outlined here with one successful test meaning another can now be run. This schedule will be defined in this section
\subsection{Device Functionality}
Functions and features of the device. How the device is intended to perform
\subsection{Evaluation}
How the device performed on each of the tests that were conducted. What areas now need to be improved to move towards a more complete prototype
\subsection{Implementation of the Prototype}
How the prototype will be implemented. What considerations need to be taken when implementing and what conclusions can we draw from the testing that affect the implementation of the prototype

\section{Further Work}
How might the device be improved? What extra features could be included next time and how might a different SDLC have an effect on the design and functionality of this product

\section{Conclusions}
What did I learn while doing this project. What went wrong and what was done well. Is the device created as useful as was initially thought? Is the way I did this project the most effective way to achieve the intended result? 

\pagebreak
\bibliographystyle{unsrt}
\bibliography{biblio}

\end{document}
